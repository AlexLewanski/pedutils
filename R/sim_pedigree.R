#####################################
#####################################
### PEDIGREE SIMULATION FUNCTIONS ###
#####################################
#####################################

### OVERVIEW ###
# The main function for pedigree simulation is sim_simple_ped. Since the simulation contains
# stochastic components, it is possible for a population to become extirpated before the
# specified number of cycles is completed. To repeatedly simulate a pedigree until you have
# one that survives for the specified number of cycles, you can use sim_ped_repeat_attempt,
# which is wrapper for sim_simple_ped.

#The general workflow for creating a pedigree:
# (1) survival_explanatory_vis: use this function to figure out the details of the
#  |                            offspring survival and age-dependent mortality functions
#  |
#  V
# (2) sim_simple_ped or sim_ped_repeat_attempt: simulate the pedigree
#  |
#  |
#  V
# (3) extract_ped: the pedigree simulation functions simulate the population while recording
#                  the pedigree information, and they output the individuals that are alive
#                  each cycle. To extract an abbreviated version of the pedigree that just
#                  contains the parent offspring relationships, you can pass the output of
#                  sim_simple_ped or sim_ped_repeat_attempt to extract_ped.

### USAGE NOTES ###
# - Make sure that safeguard is substantially above max_pop (e.g. 25% higher). If these values
#   are near each other,the population may exceed max_pop slightly and also exceed the safeguard
#   and then the simulation will halt. To completely remove the safeguard, you can set safeguard
#   to Inf.


### REQUIRED PACKAGES ###
#library(tidyverse)
##(more specifically, it requires dplyr for the main simulation function and ggplot2 for the
#visualization of survival functions (survival_explanatory_vis)


### SIMULATION INFORMATION: ###
# sim_simple_ped simulates a pedigree with overlapping generations and (optional) migration.
# sim_simple_ped outputs the census of all living individuals for each cycle. To extract the
# pedigree, you can pass the output of sim_simple_ped to the extract_ped function. You can visualize
# the functions used for determining offspring survival and age-dependent mortality probability
# using the function survival_explanatory_vis.
#
# The simulation involves the following steps:
#
# (PRESTEP) Creation of founder generation
#     - the user can input the founder generation or the function can generate founders
#     - if the founders are generated by the function, sex is randomly assigned and age
#       is determined for each individual by a draw from a user-parameterized poisson
#       distribution
#     - the parents of founders are recorded as "0" (similar to the format of pedtools)
#
# (1) Determine surviving individuals
#     - uses logistic function to determine age-dependent probability of mortality and then
#       draws a value from a binomial distribution parameterized with this probability
#     - if the population size is 0 (and no migrants are added), simulation halts because
#       population is extirpated
#
# (2) Add migrants (optional)
#     - add migrants based on a draw from a user-parameterized poisson distribution or from
#       a user-defined number of migrants
#     - if the population size is 0 after this step, simulation halts because population is
#       extirpated
#     - migrants are added with a user-defined age (this could be made more flexible)
#
# (3) Reproduction
#     - mating pairs are created by choosing individuals above the user-defined minimum age
#       from one sex (with probability prob_pair) and then randomly choosing an individual
#       with replacement of the other sex (above the specified age threshold) to represent
#       the mate
#     - each pair produces a number of offspring based on a draw from a user-parameterized
#       poisson distribution, and sex is randomly assigned to each offspring
#
# (4) Offspring survival
#     - offspring survival is determined by random draw from a binomial distribution parameterized
#       with a probability that is a linear function of maximum survival probability (when population
#       is 0), current population size, and a user-defined maximum population size (survival is 0 when
#       current population size is equal or greater than maximum population size)
#     - This step regulates population size


### ARGUMENTS ###
#founders
#   default: 20 (accepts integer values and dataframe)
#   description: the user can either input the founders or have the function generate
#                founders by inputting an integer, which defines the the number of
#                founders to create.
#                - If the user wants to input the founders, the dataframe needs to
#                  include the following columns in the specified order:
#                  'id', 'sex', 'birth_year', 'age'
#




# cycles
#   default: 5 (accepts integer values)
#   description: the number years/reproduction cycles
#
# start_year
#   default: 2020 (accepts integer)
#   description: the starting year of the population
#
# age_mort_horizontal_shift
#   default: -1.5
#   description: this is equivalent to the beta0 term in a logistic regression.
#                age_mort_horizontal_shift shifts the horizontal location of the transition
#                from low to high probability (or vice versa) with smaller values shifting
#                the curve to the right.
#
# age_mort_slope
#   default: 0.425
#   description: this is equivalent to the beta1 term in a logistic regression. age_mort_slope
#                alters the slope of function with higher values resulting in a more severe
#                transition from low to high probability (or vice versa)
#
# max_hatchling_survive_prob
#   default: 0.8  (numeric between 0 and 1)
#   description: maximum probability of hatchling survival (this is the survival
#                when the population is 0)
#
# prob_pair
#   default: (numeric between 0 and 1)
#   description: probability of mating each year for the sex that is first chosen for
#                mating (currently age independent)
#
# pair_up_order
#  default: f_to_m
#  description: the order in which the sexes are paired up. 'f_to_m' chooses females
#               first and then pairs them (with replacement) with males. 'm_to_f' does
#               the opposite
#
# min_age_reproduction
#   default: 1 (non-negative integer)
#   description: the minimum age threshold for possible reproduction. For example,
#                an age of 1 means that all individuals can potentially reproduce
#                the year after they are born
#
# add_immigrants
#   options: 'none', 'random', 'custom'
#   description: how and whether migrants should be added to the population. There
#                are 3 options:
#                (1) none: no migrants are added
#                (2) random: for each cycle, the number of migrants is drawn from a
#                            poisson distribution parameterized with founder_age_lambda
#                (3) custom: the user provides the number of migrants for each cycle
#                            using the immigrant_vec argument.
#
# immigrant_vec
#   default: NULL
#   description: a vector containing the number of migrants for each cycle. The vector
#                needs to be the same length as the number of cycles. This argument is
#                only relevant when add_immigrants is set to custom.
#
# founder_age_lambda
#   default: 4
#   description: the poisson lambda value for determining age of founders when
#                add_immigrants is set to random
#
# offspring_lambda
#   default: 5
#   description: the poisson value for the number of offspring for each breeding pair
#
# immigrant_age
#   default: 1
#   description: what age should the immigrants be considered (this could be made more
#                flexible)
#
# immigrant_prob
#   default: 2
#   description: the poisson lambda value for determine the number of migrants to add
#                each cycle
#
# safeguard
#   default: 5000
#   description: if the population size exceeds this value, the simulation will be halted
#                this is included to prevent a population explosion
#   NOTE: this is largely superfluous now because of population regulation via max_pop
#
# max_pop
#   default: 1000
#   description: the population carrying capacity, which is used to determine offspring
#                survival. This is used for population size regulation.
#
# report_progress
#    default: TRUE (logical)
#    description: specifies whether the function should report the progress of the simulation


### TO DO ###
# - make sure that naming of individuals (including by users for custom input of founders) is
#   robust

##########################################
### PEDIGREE SIMULATION  MAIN FUNCTION ###
##########################################

sim_simple_ped <- function(founders = 20,
                           cycles = 5,
                           start_year = 2020,
                           age_mort_horizontal_shift = -1.5,
                           age_mort_slope = 0.425,
                           max_hatchling_survive_prob = 0.8,
                           prob_pair = 0.8,
                           pair_up_order = c('f_to_m', 'm_to_f'),
                           min_age_reproduction = 1,
                           add_immigrants = c('none', 'random', 'custom'),
                           immigrant_vec = NULL,
                           immigrant_age = 1,
                           immigrant_prob = 2,
                           founder_age_lambda = 4,
                           offspring_lambda = 5,
                           safeguard = 50000,
                           max_pop = 1000,
                           report_progress = TRUE) {

  #=========================
  #=== SIMULATION SET-UP ===
  #=========================

  ### checking arguments ###
  #TO DO: adding checks for other arguments
  report_progress <- isTRUE(report_progress)
  pair_up_order <- match.arg(pair_up_order, choices = c('f_to_m', 'm_to_f'), several.ok = FALSE)

  #migration checking and processing
  add_immigrants <- match.arg(add_immigrants, choices = c('none', 'random', 'custom'), several.ok = FALSE)
  if (add_immigrants == 'random') immigrant_vec <- stats::rpois(n = cycles, lambda = immigrant_prob)
  if (add_immigrants == 'custom') {
    if (is.null(immigrant_vec))
      stop('If add_immigrants is custom, then a vector of immigrant counts need to be input via immigrant_vec.')

    if (length(immigrant_vec) != cycles)
      stop('immigrant_vec needs to be the same length as the number of cycles')
  }



  #===========================
  #=== PEDIGREE SIMULATION ===
  #===========================

  pop_list <- list()

  ### PRESTEP: FOUNDER CREATION ###
  if (is.data.frame(founders)) {
    if(!validate_founder_df(founders)) stop('The dataframe for founders is invalid')
    pop_list[[paste0('year_', start_year)]] <- founders
  } else {
    pop_list[[paste0('year_', start_year)]] <- create_founders(n = founders,
                                                               start_year = start_year,
                                                               age_lambda = founder_age_lambda)
  }

  pop_list[[paste0('year_', start_year)]]$sire <- '0'
  pop_list[[paste0('year_', start_year)]]$dam <- '0'
  pop_list[[paste0('year_', start_year)]]$year <- start_year

  column_order <- colnames(pop_list[[paste0('year_', start_year)]])
  column_order <- column_order[-length(column_order)]

  id_index <- 1 #index for naming offspring (non-founders and non-migrants)
  migrant_index <- 1 #index for naming migrants

  if (report_progress) prog_bar <- utils::txtProgressBar(min = 0, max = cycles, initial = 0, char = "*", style = 3)

  for (INDEX in seq_len(cycles)) {

    ### STEP 1. DETERMINE SURVIVING INDIVIDUALS ###
    #if this is the first cycle, have all the founders survive to reproduction
    if (INDEX == 1) {
      surviving_indivs <- pop_list[[paste0('year_', start_year + INDEX - 1)]]
    } else {
      #for cycles 2+, determine survival based on age-explicit mortality probability function

      #indices of individuals that survived
      surviving_indivs_index <- which(age_mort_func(age = pop_list[[paste0('year_', start_year + INDEX - 1)]]$age,
                                                    age_mort_horizontal_shift = age_mort_horizontal_shift,
                                                    age_mort_slope = age_mort_slope)$mort_draw == 0) #0.425

      surviving_indivs <- pop_list[[paste0('year_', start_year + INDEX - 1)]][surviving_indivs_index,]

      #if there are no surviving individuals and no migrants are being added, then the population is deceased
      if (nrow(surviving_indivs) == 0 & add_immigrants == 'none') stop("Population is extirpated.")

      surviving_indivs$age <- surviving_indivs$age + 1

    }


    ### STEP 2. (OPTIONAL) ADDITION OF MIGRANTS ###
    if (add_immigrants != 'none') {

      #add some migrants
      immigrant_df <- create_immigrant_founders(n = immigrant_vec[INDEX], #rpois(n = 1, lambda = immigrant_prob),
                                                start_year = NA, #start_year + INDEX,
                                                id_index = migrant_index,
                                                age = immigrant_age) #start_year + INDEX

      if (nrow(immigrant_df) > 0) immigrant_df$year <- start_year + INDEX

      migrant_index <- migrant_index + nrow(immigrant_df)

      #combine the survivors in the population and the new migrants into a single datafrmae
      ##if surviving_indivs and immigrant_df and empty, this means that there are no survivors
      #nad no migrants so the population is extirprated.
      surviving_indivs <- tryCatch(rbind_empty_handle(surviving_indivs, immigrant_df),
                                   error = function(e){
                                     stop("Population is extirpated.")
                                   })
    }


    ### STEP 3. REPRODUCTION ###

    #determine the individuals
    #halt simulation if one of the sexes doesn't exist (or doesn't have old enough individuals based on min_age)
    mate_pair_up <- tryCatch(pair_up(df = surviving_indivs,
                                     prob_pair = prob_pair,
                                     order = pair_up_order, min_age = min_age_reproduction),
                             error = function(e){
                               stop("Population unable to complete reproduction step. \nEither one of the sexes doesn't exist or one of the sexes doesn't exist above the specific minimum age.")
                             })


    #determine the number of offspring for each individual
    mate_pair_up$offspring_count <- stats::rpois(nrow(mate_pair_up), lambda = offspring_lambda)

    #add a row for each offspring
    offspring_df <- mate_pair_up[rep(seq_len(nrow(mate_pair_up)), times = mate_pair_up$offspring_count), -3]


    ### STEP 4. OFFSPRING SURVIVAL ###
    offspring_df_survived <- offspring_survival(offspring_df = offspring_df,
                                                max_hatchling_survive_prob = max_hatchling_survive_prob,
                                                current_pop_size = nrow(surviving_indivs),
                                                max_pop = max_pop)


    #add additional info to the offspring dataframe if surviving offspring exist
    if (nrow(offspring_df_survived) != 0) {
      #adding info to offspring df
      id_max <- nrow(offspring_df_survived) + id_index - 1
      offspring_df_survived$id <- paste0('ID', id_index:id_max)
      offspring_df_survived$sex <- sample(c('M', 'F'), nrow(offspring_df_survived), replace = TRUE)
      offspring_df_survived$age <- 0
      offspring_df_survived$birth_year <- start_year + INDEX #year + 1

      offspring_df_survived <- offspring_df_survived[,column_order]

      id_index <- id_max + 1
    }

    #add the dataframe that includes the survivors, migrants, and offspring
    pop_list[[paste0('year_', start_year + INDEX)]] <- rbind_empty_handle(surviving_indivs[colnames(surviving_indivs) != 'year'],
                                                                          offspring_df_survived)

    pop_list[[paste0('year_', start_year + INDEX)]]$year <- start_year + INDEX

    if (nrow(pop_list[[paste0('year_', start_year + INDEX)]]) > safeguard)
      stop('Population exceeded safeguard.')

    if (report_progress) utils::setTxtProgressBar(prog_bar, INDEX)
  }

  pop_df <- dplyr::bind_rows(pop_list)
  rownames(pop_df) <- NULL

  return(pop_df)
}

#' Simulate a simple population and record pedigree
#'
#' @param attempts If the simulation "fails" (the population goes extinct before the number of cycles), attempts is the number of times to retry the simulation to achieve success.
#' @param founders Specifications for the founders of the population. The user can either input the founders or have the function generate founders by inputting an integer, which defines the the number of founders to create. If the user wants to input the founders, the dataframe needs to include the following columns in the specified order: 'id', 'sex', 'birth_year', 'age'
#' @param cycles The number of years/reproduction cycles (accepts an integer value; default = 5).
#' @param start_year The starting year of the population (accepts an integer value; default 2020).
#' @param age_mort_horizontal_shift This is equivalent to the beta0 term in a logistic regression. age_mort_horizontal_shift shifts the horizontal location of the transition from low to high probability (or vice versa) with smaller values shifting the curve to the right (default = -1.5).
#' @param age_mort_slope This is equivalent to the beta1 term in a logistic regression. age_mort_slope alters the slope of function with higher values resulting in a more severe transition from low to high probability (or vice versa).
#' @param max_hatchling_survive_prob Maximum probability of hatchling survival. This is the survival probability when the population size is 0 (numeric value between 0 and 1; default = 0.8  numeric between 0 and 1).
#' @param prob_pair Probability of mating each year for the sex that is first chosen for mating (currently age independent)
#' @param pair_up_order The order in which the sexes are paired up. 'f_to_m' chooses females first and then pairs them (with replacement) with males. 'm_to_f' does the opposite
#' @param min_age_reproduction The minimum age threshold for possible reproduction. For example, an age of 1 means that all individuals can potentially reproduce the year after they are born
#' @param add_immigrants How and whether migrants should be added to the population. There are 3 options: (1) none: no migrants are added (2) random: for each cycle, the number of migrants is drawn from a poisson distribution parameterized with founder_age_lambda (3) custom: the user provides the number of migrants for each cycle using the immigrant_vec argument.
#' @param immigrant_vec A vector containing the number of migrants for each cycle. The vector needs to be the same length as the number of cycles. This argument is only relevant when add_immigrants is set to custom.
#' @param immigrant_age What age should the immigrants be considered (this could be made more flexible)
#' @param immigrant_prob The poisson lambda value for determine the number of migrants to add each cycle.
#' @param founder_age_lambda The poisson lambda value for determining age of founders when add_immigrants is set to random.
#' @param offspring_lambda The poisson value for the number of offspring for each breeding pair.
#' @param safeguard If the population size exceeds this value, the simulation will be halted this is included to prevent a population explosion. NOTE: this is largely superfluous now because of population regulation via max_pop.
#' @param max_pop The population carrying capacity, which is used to determine offspring survival. This is used for population size regulation.
#' @param report_progress Specifies whether the function should report the progress of the simulation.
#'
#' @return A dataframe containing the population simulation output.
#' @export
#'
#' @examples
sim_ped_repeat_attempt <- function(attempts = 10L,
                                   founders = 20L,
                                   cycles = 5L,
                                   start_year = 2020,
                                   age_mort_horizontal_shift = -1.5,
                                   age_mort_slope = 0.425,
                                   max_hatchling_survive_prob = 0.8, #probability of hatchling surviving
                                   prob_pair = 0.8, #probability of mating each year (currently age independent)
                                   pair_up_order = c('f_to_m', 'm_to_f'),
                                   min_age_reproduction = 1,
                                   add_immigrants = c('custom', 'random', 'none'),
                                   immigrant_vec = NULL,
                                   immigrant_age = 1, #what age is the immigrants added at
                                   immigrant_prob = 2, #lambda parameter for the number of migrants added each cycle
                                   founder_age_lambda = 4,
                                   offspring_lambda = 5,
                                   safeguard = 5000, #this is superfluous now because of max_pop
                                   max_pop = 1000,
                                   report_progress = TRUE) {
  tries <- 0
  ped_output <- FALSE

  while (tries <= attempts & !is.data.frame(ped_output)) {

    ped_output <- tryCatch(sim_simple_ped(founders = founders,
                                          cycles = cycles,
                                          start_year = start_year,
                                          age_mort_horizontal_shift = age_mort_horizontal_shift, #-2.25, #-1.5,
                                          age_mort_slope = age_mort_slope,
                                          max_hatchling_survive_prob = max_hatchling_survive_prob,
                                          prob_pair = prob_pair,
                                          pair_up_order = pair_up_order,
                                          min_age_reproduction = min_age_reproduction,
                                          add_immigrants = add_immigrants,
                                          immigrant_vec = immigrant_vec,
                                          immigrant_age = immigrant_age,
                                          immigrant_prob = immigrant_prob,
                                          founder_age_lambda = founder_age_lambda,
                                          offspring_lambda = offspring_lambda,
                                          safeguard = safeguard,
                                          max_pop = max_pop,
                                          report_progress = report_progress),
                           error = {function(e) return(e)})
    tries <- tries + 1
  }

  if (!is.data.frame(ped_output)) stop('The last attempt returned the following error message:\n', ped_output)
  message('\nNumber of attempts until success: ', tries)
  return(ped_output)
}



############################################
### PEDIGREE SIMULATION HELPER FUNCTIONS ###
############################################

offspring_survival_prob <- function(pop, pop_max, max_hatchling_survive_prob = 1) {
  return(max_hatchling_survive_prob*(1 - min(pop, pop_max)/pop_max))
}

validate_founder_df <- function(founders) {
  if (!identical(colnames(founders), c('id', 'sex', 'birth_year', 'age'))) return(FALSE)
  if (nrow(founders) < 1) return(FALSE)

  return(TRUE)
}

create_founders <- function(n = 10, start_year = 1990, age_lambda = 3) {
  return(
    data.frame(
      id = paste0('F' , seq_len(n)),
      sex = sample(c('M', 'F'), n, replace = TRUE),
      birth_year = start_year,
      age = stats::rpois(n = seq_len(n), lambda = age_lambda)
    )
  )
}


age_mort_func <- function(age, age_mort_horizontal_shift = 0.5, age_mort_slope = 1) {
  prob_mort <- exp(age_mort_horizontal_shift + age*age_mort_slope)/(1 + exp(age_mort_horizontal_shift + age*age_mort_slope))

  return(
    data.frame(
      prob_mort = prob_mort,
      mort_draw = stats::rbinom(n = length(prob_mort), size = 1, prob = prob_mort)
    )
  )
}


create_immigrant_founders <- function(n = 10, start_year = 1990, id_index = 1, age = NA) {
  if (n == 0) return(data.frame())
  return(
    data.frame(
      id = paste0('MIG' , id_index:(id_index + n - 1)),
      sex = sample(c('M', 'F'), n, replace = TRUE),
      birth_year = start_year,
      age = age,
      sire = '0',
      dam = '0'
    )
  )
}


pair_up <- function(df,
                    prob_pair,
                    order = c('m_to_f', 'f_to_m'),
                    min_age = 0) {

  if (!all(c('M', 'F') %in% df$sex[df$age >= min_age]) )
    stop("One of the sexes with a valid minimum age doesn't exist")

  pairing_order <- toupper(strsplit(order, split = "_to_")[[1]])

  column_names <- switch(order,
                         'm_to_f' = {c('sire', 'dam')},
                         'f_to_m' = {c('dam', 'sire')})

  #choose the first sex and subset based on probability prob_pair
  mates_sex1_pre <- df[df$sex == pairing_order[1] & df$age >= min_age,]$id
  mates_sex1 <- mates_sex1_pre[as.logical(stats::rbinom(length(mates_sex1_pre), 1, prob = prob_pair))]

  #match individuals of the 2nd sex to first sex (with replacement)
  mates_sex2 <- sample(df[df$sex == pairing_order[2] & df$age >= min_age,]$id, size = length(mates_sex1), replace = TRUE)

  output_df <- data.frame(mates_sex1,
                          mates_sex2)
  colnames(output_df) <- column_names

  return(output_df[,match(c('sire', 'dam'), column_names)])
}



offspring_survival <- function(offspring_df, max_hatchling_survive_prob, current_pop_size, max_pop) {
  if (nrow(offspring_df) == 0) return(data.frame())

  survival_prob <- offspring_survival_prob(pop = current_pop_size, pop_max = max_pop, max_hatchling_survive_prob = max_hatchling_survive_prob)

  #determine which year 0 offspring survive
  offspring_survival_info <- stats::rbinom(nrow(offspring_df), 1, prob = survival_prob)

  offspring_survival_eval <- as.logical(offspring_survival_info)

  if (all(!offspring_survival_eval)) {
    offspring_df_survived <- data.frame()
  } else {
    offspring_df_survived <- offspring_df[offspring_survival_eval,]
  }

  return(offspring_df_survived)
}

rbind_empty_handle <- function(df1, df2) {
  if (nrow(df1) == 0 & nrow(df2) == 0) stop('Both dataframes are empty.')
  if (nrow(df1) == 0) return(rbind(df2, df2[0,]))
  if (nrow(df2) == 0) return(rbind(df1, df1[0,]))

  return(rbind(df2, df1))
}



#####################################################################
### PEDIGREE SIMULATION POST-PROCESSING AND EXPLORATION FUNCTIONS ###
#####################################################################

#' Plot survival probability
#'
#' @param age_mort_horizontal_shift This is equivalent to the beta0 term in a logistic regression. age_mort_horizontal_shift shifts the horizontal location of the transition from low to high probability (or vice versa) with smaller values shifting the curve to the right (default = -1.5).
#' @param age_mort_slope This is equivalent to the beta1 term in a logistic regression. age_mort_slope alters the slope of function with higher values resulting in a more severe transition from low to high probability (or vice versa).
#' @param min_plotting_age The minimum age to include in the plot.
#' @param max_plotting_age The maximum age to include in the plot.
#' @param max_pop The population carrying capacity, which is used to determine offspring survival. This is used for population size regulation.
#' @param max_hatchling_survive_prob Maximum probability of hatchling survival. This is the survival probability when the population size is 0.
#'
#' @return A plot (ggplot object) visualizing the relationship between age and survival probability.
#' @import dplyr
#' @import ggplot2
#' @importFrom rlang .data
#' @export
#'
#' @examples
survival_explanatory_vis <- function(age_mort_horizontal_shift = -1.5,
                                     age_mort_slope = 0.6,
                                     min_plotting_age = 0,
                                     max_plotting_age = 20,
                                     max_pop = 1000,
                                     max_hatchling_survive_prob = 0.6) {

  plot_list <- list()

  #plot1: Mortality function
  age_vec <- seq(min_plotting_age, max_plotting_age, by = 1)
  plot_list[['age_mortality_plot']] <- age_mort_func(age = age_vec,
                                                     age_mort_horizontal_shift = age_mort_horizontal_shift,
                                                     age_mort_slope = age_mort_slope) %>%
    dplyr::mutate(age = age_vec) %>%
    ggplot2::ggplot() +
    ggplot2::geom_point(aes(x = .data$age, y = .data$prob_mort),
                        color = "#737373", size = 3, alpha = 1) +
    #geom_point(aes(x = age, y = mort_draw)) +
    ggplot2::theme_bw() +
    ggplot2::xlab('Age') +
    ggplot2::ylab('P(mortality)')

  pop_vec <- seq(1, max_pop, by = 1)
  offspring_survival_vec <- sapply(pop_vec, function(x) offspring_survival_prob(pop = x, pop_max = max_pop, max_hatchling_survive_prob = max_hatchling_survive_prob))
  plot_list[['offspring_survival_plot']] <- data.frame(pop = pop_vec,
                                                       offspring_prob_survive = offspring_survival_vec) %>%
    ggplot2::ggplot() +
    ggplot2::geom_line(aes(x = .data$pop, y = .data$offspring_prob_survive),
                       size = 2, color = "#737373") +
    ggplot2::theme_bw() +
    ggplot2::xlab('Population size') +
    ggplot2::ylab('P(offspring survival)')

  return(plot_list)
}


#' Extract pedigree from population simulation
#'
#' @param ped_sim_output Population simulation output from the sim_ped_repeat_attempt function.
#' @param remove_nonbreeding_founders Logical (TRUE or FALSE) indicating whether to remove founders from the population that didn't have any offspring.
#' @param pedtools_format Logical (TRUE or FALSE) indicating whether to output the pedigree in pedtools format.
#'
#' @return A dataframe containing pedigree information.
#' @import dplyr
#' @importFrom rlang .data
#' @export
#'
#' @examples
extract_ped <- function(ped_sim_output,
                        remove_nonbreeding_founders = TRUE,
                        pedtools_format = TRUE) {

  #it doesn't work to extract the year that equals the birth year because this
  #will not properly include founders (including migrant founders), whose birth
  #year isn't known
  ped_filter <- ped_sim_output %>%
    #mutate(sex = if_else(sex == 'M', 1, 2)) %>%
    dplyr::group_by(.data$id) %>%
    dplyr::filter(.data$year == min(.data$year)) %>%
    dplyr::ungroup()

  #if remove_nonbreeding_founders = TRUE, founders that aren't parents
  #are removed from the pedigree
  if (isTRUE(remove_nonbreeding_founders)) {
    solo_founders <- ped_filter %>%
      dplyr::filter(!(.data$id %in% .data$sire) & !(.data$id %in% .data$dam)) %>%
      dplyr::filter(.data$sire == '0' & .data$dam == '0') %>%
      dplyr::pull(.data$id)

    ped_filter <- ped_filter %>%
      dplyr::filter(!.data$id %in% solo_founders)
  }

  if (isTRUE(pedtools_format)) {
    ped_filter <- ped_filter %>%
      dplyr::mutate(sex = dplyr::if_else(.data$sex == 'M', 1, 2)) %>%
      dplyr::select(.data$id, .data$sire, .data$dam, .data$sex) %>%
      dplyr::rename(fid = .data$sire, mid = .data$dam)
  }

  return(as.data.frame(ped_filter))
}



####################################
### PEDIGREE SIMULATION EXAMPLES ###
####################################

# ### EXAMPLE 1 ###
# #no migration
# #function creates founders
#
# examp1_plots <- survival_explanatory_vis(age_mort_horizontal_shift = -1.5,
#                                          age_mort_slope = 0.5,
#                                          min_plotting_age = 1,
#                                          max_plotting_age = 20,
#                                          max_pop = 5000,
#                                          max_hatchling_survive_prob = 0.8)
#
# cowplot::plot_grid(examp1_plots$age_mortality_plot +
#                      ylim(0,1),
#                    examp1_plots$offspring_survival_plot +
#                      ylim(0,1), nrow = 1)
#
#
# examp1_pedsim <- sim_ped_repeat_attempt(attempts = 3,
#                                         founders = 20,
#                                         cycles = 10,
#                                         start_year = 1930,
#                                         age_mort_horizontal_shift = -1.5,
#                                         age_mort_slope = 0.5,
#                                         max_hatchling_survive_prob = 0.8,
#                                         prob_pair = 0.7,
#                                         add_immigrants = 'none',
#                                         immigrant_vec = NULL,
#                                         founder_age_lambda = 3,
#                                         offspring_lambda = 2,
#                                         immigrant_age = 5,
#                                         immigrant_prob = 5,
#                                         safeguard = 10000,
#                                         max_pop = 5000,
#                                         report_progress = FALSE)
#
# examp1_extract_ped <- extract_ped(examp1_pedsim,
#                                   remove_nonbreeding_founders = TRUE,
#                                   pedtools_format = FALSE)



# ### EXAMPLE 2A ###
# #migration (function determines the number of migrants)
# #user input of founders
#
# examp2_founders <- data.frame(
#   id = paste0('Founder', 1:30),
#   sex = rep(c('F', 'M'), each = 15),
#   birth_year = 2000,
#   age = rpois(30, 4)
# )
#
# examp2a_pedsim <- sim_simple_ped(founders = examp2_founders,
#                                 cycles = 20,
#                                 start_year = 2000,
#                                 age_mort_horizontal_shift = -1.5,
#                                 age_mort_slope = 0.5,
#                                 max_hatchling_survive_prob = 0.8,
#                                 prob_pair = 0.7,
#                                 add_immigrants = 'random',
#                                 immigrant_vec = NULL,
#                                 founder_age_lambda = 3,
#                                 offspring_lambda = 2,
#                                 immigrant_age = 5,
#                                 immigrant_prob = 5,
#                                 safeguard = 10000,
#                                 max_pop = 5000,
#                                 report_progress = FALSE)
#
# examp2a_extract_ped <- extract_ped(examp2a_pedsim,
#                                   remove_nonbreeding_founders = TRUE,
#                                   pedtools_format = TRUE)


# ### EXAMPLE 2B ###
# #user-input of migration
# #user input of founders
#
# #10 migrants per cycle
# examp2_mig_vec <- rep(10, 20)
#
# examp2b_pedsim <- sim_simple_ped(founders = examp2_founders,
#                                  cycles = 20,
#                                  start_year = 2000,
#                                  age_mort_horizontal_shift = -1.9,
#                                  age_mort_slope = 0.6,
#                                  max_hatchling_survive_prob = 0.8,
#                                  prob_pair = 0.7,
#                                  add_immigrants = 'custom',
#                                  immigrant_vec = examp2_mig_vec,
#                                  founder_age_lambda = 3,
#                                  offspring_lambda = 2,
#                                  immigrant_age = 5,
#                                  immigrant_prob = 5,
#                                  safeguard = 10000,
#                                  max_pop = 5000,
#                                  report_progress = FALSE)
#
# examp2b_extract_ped <- extract_ped(examp2b_pedsim,
#                                    remove_nonbreeding_founders = TRUE,
#                                    pedtools_format = TRUE)


# ### EXAMPLE 3 ###
# #here is an example of a simulation where the population may become extirpated before
# #the last cycle (small number of founders, fairly low offspring survival). Thus, this
# #is a case where the repeated simulation wrapper could be helpful. With 6 founders,
# #20 cycles, and maximum offspring survival of 0.5, it takes 266 attempts for the
# #simulation to complete successfully when the seed is set to 171.
#
# set.seed(171)
# examp3_pedsim <- sim_ped_repeat_attempt(attempts = 2000,
#                                         founders = 6,
#                                         cycles = 20,
#                                         start_year = 2005,
#                                         age_mort_horizontal_shift = -1.5,
#                                         age_mort_slope = 0.5,
#                                         max_hatchling_survive_prob = 0.5,
#                                         prob_pair = 0.7,
#                                         add_immigrants = 'none',
#                                         immigrant_vec = NULL,
#                                         founder_age_lambda = 3,
#                                         offspring_lambda = 2,
#                                         immigrant_age = 5,
#                                         immigrant_prob = 5,
#                                         safeguard = 10000,
#                                         max_pop = 5000,
#                                         report_progress = FALSE)
#
# examp3_extract_ped <- extract_ped(examp3_pedsim,
#                                   remove_nonbreeding_founders = TRUE,
#                                   pedtools_format = TRUE)
#
# #visualizing the pedigree with the pedtools package
# library(pedsuite)
#
# plot(
#   pedtools::ped(id = examp3_extract_ped$id,
#                 fid = examp3_extract_ped$fid,
#                 mid = examp3_extract_ped$mid,
#                 sex = examp3_extract_ped$sex), cex = 0.6
# )
